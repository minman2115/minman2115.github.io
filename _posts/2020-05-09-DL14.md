---
layout: post
title: "DenseNet 기초개념"
tags: [딥러닝]
comments: true
---

.

Deep_Learning_TIL(20190727)

study program : https://www.fastcampus.co.kr/data_camp_deeplearning

[학습노트]

- 최근에 네트워크를 만들때 중요하게 생각하는 것은 레이어를 쌓는 것도 중요하지만 '채널수'를 네트워크를 크게 만들거냐 작게만들거냐를 좌우하게 된다. 채널수는 내가 그 레이어에서 컨볼루션 필터를 몇개 쓰냐에 따라서 아웃풋의 채널수가 결정되고 그게 다음의 인풋으로 들어가게 될 것이다. 


- ResNet이 왜 2015년도에 대회를 석권하고 성능이 잘 나올까 사람들이 연구를 했고 두가지 해석이 있다. 첫번째는 구글넷은 22레이어짜리인데 그것도 학습이 잘 안되서 중간에 브랜치 따고 학습하는 구조였는데 레즈넷은 152 레이어나 쌓았는데도 구글넷과 같은 브랜치가 없이 학습을 시켰다. 그게 어떻게 가능했냐면 skip connection(identity mapping을 건너뜀. 앞에서부터 뒤로 바로 건너뛰는 shortcut connection) 때문에 가능했다고 볼 수 있다. 베니싱그레디언트를 방지하여 그레디언트를 스트롱 플로우 형태로 가져갔다. 두번째는 앙상블 같은 효과가 있다는 것이다. 인풋에서 아웃풋까지 가는길이 하나가 아니기 때문이다. 상당히 다양하게 아웃풋으로 가는 방법이 있다. 이 다양한 방법들이 각각 다른 네트워크처럼 동작해서 좋은성능을 낸다는 것이다. ResNet은 CNN을 구현한다고 하면 베이스라인으로 가장 많이 쓰인다고 할 수 있다. 어쨌든 152레이어가 많기 때문에 이거를 줄인 ResNet의 파생버전들도 있다. 예를들어서 ResNet50이라는 모델이 있는데 말그대로 50레이어 구조의 네트워크고 캐라스에서 가장 많이 쓰이는 모델이라고 한다.


### DenseNet

![image](https://user-images.githubusercontent.com/41605276/81396782-00d47400-9161-11ea-8829-6cc1d4128435.png)

댄스넷은 대회에 나간 모델은 아니지만 CVPR이라는 유명한 학회가 있는데 거기에서 2017년에 베스트 페이퍼로 선정되었다. 이 모델도 성능이 잘나오고 대중적으로도 많이 쓰인다.

일반적으로 CNN이라고 하면 이미지가 RGB 세개의 채널로 들어오면 컨볼루션 연산을 할것이고 필터를 얼마나 쓰냐에 따라 채널수도 결정될 것이다. ResNet은 위에 그림에서 알 수 있듯이 중간중간 건너 뛰는 것을 만들어서 덧셈을 해주는 형태였다. 댄스넷은 위에 그림과 같은 구조이다. 인풋에서 아웃풋까지 모든 스텝에서 skip connection이 존재하고, 합쳐질때 concatenation을 한다. 그런데 아웃풋으로 나오는 것의 채널수를 일정하게 유지를 한다. 단계를 거칠때마다 위에 그림과 같이 컨볼루션 연산한번하고 concatenation하면 2k 그다음은 3k, 4k, 5k로 커지게 되는 구조이다.

RGB 인풋이 세개가 들어오면 컨볼루션 연산을할때 매레이어마다 컨볼루션 필터의 숫자가 동일하다. 그래서 입력이 뭐가들어오던지 아웃풋은 채널이 예를들어 10으로 정했으면 10개의 채널만 나오게 되어있다. 

위에 그림에서의 예를들면 첫번째 레이어가 3이 나오는 것이다. 그리고 노란색부분만 컨볼루션 연산을해서 넘기고 3으로 나온것과 concatenation을 한다. 그러면 채널이 6짜리가 생기고 그게 인풋으로 다음단계에 들어갈 것이다. 그리고 컨볼루션해서 연산결과가 빨간색부분만 이 레이어의 출력이다. 그리고 또 빨간색부분 말고 안들어갔던 것을 붙인다. 그려면 또 채널 9개짜리가 생기고 그게 인풋으로 다음단계에 들어간다. 마찬가지로 하늘색부분만 이 레이어의 출력이고 나머지것들을 또 concatenation해서 붙인다. 그 다음에 또 다음단계로 넘기는 이런형태이다. 

실제로는 아래 그림의 맨위쪽과 같이 인풋에서 아웃풋까지 레이어 한개가 아니고 두개이상이다. 그리고 컨볼루션, 렐루, 배치놈 순서로 연산을 하는게 일반적인데 뒷쪽에 배치놈이 있는 특이한 구조다. 각각의 단계에서 크기가 다 다르고, 합쳐졌기 때문에 범위가 달라서 그거를 그냥 배치놈한것이다. 그 다음에 렐루를 통과시키고 conv를 적용한다.

![image](https://user-images.githubusercontent.com/41605276/81398675-a9d09e00-9164-11ea-8b9b-50c6996a6614.png)

그런데 입력부터 출력까지 다 가게 되면 채널이 너무 뚱뚱해지기 때문에 중간에 Dense Block형태로 만들었다. 댄스블럭이라는게 있고 댄스블럭 안에서만 fully connect가 되는 형태이다. 그래서 dense하게 connect가 되어있기 때문에 DenseNet이라고 하는 것이다. 이렇게 했더니 굉장히 성능이 잘나왔다. 왜그런지 보니까 댄스넷과 비슷했다. 내용은 아래 그림과 같다.

![image](https://user-images.githubusercontent.com/41605276/81399559-23b55700-9166-11ea-9af0-49b4e35d8569.png)

특정부분에서 애러가 발생하면 모든레이어로 다이렉트로 갈 수 있다는 장점 때문에 스트롱 그레디언트 특징이 있다. 그 다음에 또 하나의 장점으로 파라미터의 수가 적고, computational efficiency가 있다는 것이다. 입력과 출력의 채널이 똑같은 레즈넷의 어떤 레이어의 연산량을 보면 대략 채널의 제곱(결국에 연산량은 채널의 수에 비례한다(fully connected레이어가 없고, 컨볼루션만 있다는 가정하에))에 비례하는 것을 알 수 있다. 가로세로에도 영향을 받기는 한데 레즈넷이나 댄스넷이나 동일하니까. 채널만 따진것이다. 예를들어서 컨볼루션만 하는 구조라고 할때 레이어가 10개였다 20개가 되면 연산량이 두배가 되고, 채널을 두배로 늘리면 연산량은 네배가 된다. 가로세로가 정사각형이라고 할때 이거를 두배로 늘리면 연산량은 4배가 된다. 제곱에 비례하기 때문이다. 그래서 위에 그림과 같이 lxkxk에 비례할것이다. 그런데 k는 보통12정도 잡는다.


원래 일반적인 CNN의 경우에는 입력을 받아서 컨볼루션 연산을 하고, 얘를 fully connected layer에 넣어서 연산을 하는데 fully connected layer에서 연산을 하던 글로벌 에버리지 풀링을 하고 fully connected layer에서 연산을 하던 맨마지막에 있는 피쳐만 사용하게 된다. 그런데 댄스넷은 이렇게 하지 않는다. 글로벌 에버리지 풀링을 할때 앞쪽에 concatenation 된 것을 갖다 쓴다. 무슨말이냐면 앞에 있는 피쳐맵도 classification 하는데 영향을 끼친다는 것이다. 이게 classification 뿐만 아니라 detection이나 segmentation에서도 중요한 역할을 한다. 앞에 있는 피쳐를 끌어다와서 앞쪽에 있는 피쳐의 장점(풀링연산을 안했기 때문에 resolution이 큰 장점과 위치에 대한 정보도 더 많이 갖고 있는 장점)을 가져갈 수 있다. 뒤쪽에 있는 얘들은 위치정보가 많이 없어진 대신에 하이레벨의 피쳐를 갖고 있다. 그래서 하이레벨 피쳐와 로우레벨 피쳐를 모두 고려해서 classification하기 때문에 성능이 잘 나오는 것이다. (라고 모델을 만든 사람들이 주장한다)

아래 그림을 보면 좌측과 우측의 차이는 data aumentation을 했느냐 안했느냐의 차이가 있고, 보면 항상 DenseNet이 성능이 잘나왔다는 것을 알 수 있다. data aumentation도 안했을때 ResNet은 성능이 많이 떨어졌는데 DenseNet은 크게 떨어지지 않았다. 결론적으로 비슷한 연산량과 비슷한 파라미터를 갖을때 DenseNet이 ResNet보다 성능이 낫다는 것을 보여주는 것이다. 

참고로 보면 250레이어의 댄스넷의 파라미터수가 1000레이어의 레즈넷의 파라미터수보다 훨씬 많은 것을 알 수 있다. 댄스넷이 파라미터수를 적게쓰고 연산량이 적다라고 하는 것은 레이어가 많지 않은 수준에서 얘기인것이고 이것도 레이어가 쌓이게 되면 레이어가 쌓이는거 대비해서 채널 늘어나는 수가 훨씬 크기 때문에 일정이상 쌓이게 되면 댄스넷이 오히려 더 커질 수 있다.

![image](https://user-images.githubusercontent.com/41605276/81461261-96194c00-91e5-11ea-95ab-388e137acab7.png)
