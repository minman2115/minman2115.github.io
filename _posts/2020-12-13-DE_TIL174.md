---
layout: post
title: "티아카데미 Jenkins를 활용한 CICD TIL - CICD & Jenkins 기본개념"
tags: [Data Engineering]
comments: true
---

.

Data_Engineering_TIL(20201213)

study_program : 티아카데미 Jenkins를 활용한 CI/CD

URL : https://tacademy.skplanet.com/frontMain.action

- 강의목표

1) CI/CD 파이프라인의 기본개념에 대해서 이해한다.

2) 기본적인 운영환경 (DEV, QA, PROD)이 어떻게 구성되고 운영되는지 이해한다.

사용자가 쓰는 프로덕션 환경뿐만 아니라 개발을 할때 개발자들은 일반적으로 본인들의 로컬 피시에서 개발을 하고, 개발을 한 결과물을 내부사용자 (프론트엔드 엔지니어, 백앤드 엔지니어, QA 엔지니어 등등) 들에게 전달을 하기 위해서 DEV 또는 QA 환경에서 공유가 될 것이다. 따라서 단순히 사용자가 사용하는 프로덕션 환경뿐만 아니라 개발자들이 쓰는 환경들까지 일반적으로 구축을 해서 개발을 하게된다. 그래서 CI/CD 파이프라인이라고 하면 단순하게 개발을 해서 사용자에게 배포하는것 뿐만 아니라 우리가 개발한 product를 내부사용자(QA 엔지니어, 백엔드 엔지니어, 프론트앤드 엔지니어 등등)에게 지속적으로 공유하는 것이 CI/CD의 목적이라고 할 수 있다.

3) Jenkins의 기본개념에 대해 이해한다.

4) Jenkins를 통해 기본적인 배포 파이프라인을 직접 구축할 수 있다.

5) 실제 운영기에서 특히 AWS 기반의 클라우드 환경에서 Jenkins가 어떻게 활용되는지 알 수 있다.


- CI/CD가 뭐냐

영어로는 Continuous Integration 인데 그러면 뭘 통합한다는 거야?

--> 여러 개발자들의 개발한 코드를 계속해서 통합하는 것을 말한다.

다수의 개발자들이 개발한 코드를 직접 이 개발자들이 모여 앉아서 통합하고, 코드를 고치고 이런게 아니라 여러명이 작성한 코드를 가능하면 빠르게 취합해서 배포하고자 함이 목적인 것이다.

continuous integration (CI) is the practice of merging all developers' working copies to a shared mainline several times a day

그러면 Continuous Delivery 는 뭘 딜리버리를 한다는 거야?

--> 사용자에게 product(서비스)를 지속적으로 딜리버리한다는 것이다. 개발자들이 개발한 코드를 항상 배포가능한 상태를 유지하는 것.

사용자에게만 딜리버리 아니라 내부 개발자들에게도 지속적으로 딜리버리 한다는 의미도 포함하는 개념이다.

Continuous Deployment라는 용어도 있는데 이거는 무슨의미냐?

--> 개발한 코드를 사용자가 사용가능한 환경에 배포하는 것을 자동화함.

즉, CI/CD 란 각각의 개발자들이 개발을 하는 개발 환경을 사용자가 사용 가능한 서비스로 전달하는 모든 과정을 지속 가능한 형태로 또 가능하다면 자동으로 해서 개발자와 사용자 사이의 격차를 없애는 것이다. 이러한 과정에는 코드를 빌드하고, 테스트하고 배포하는 활동이 있다.

이를 도식화하면 아래와 같다.

![1](https://user-images.githubusercontent.com/41605276/102007335-780f5d80-3d6b-11eb-8585-21cc52b6917c.png)

- CI가 왜 필요하냐? 만약에 CI가 없을때의 문제를 생각해보자.

100명의 개발자가 각자 개발 --> 1주 후 --> 매니저가 중간점검을 한다고 코드들을 취합하는데 각자 개발한 코드를 통합하는 엄청난 고통 --> 또 100명의 개발자가 각자 개발 --> 1주 후 --> "마지막에 누가 취합한거야? 내꺼 코드 안되잖아!"

취합하는 과정자체도 고통이고, 오류도 많이 발생하고, 각각의 오류 잡기도 매우 힘들고, 배포도 어려워지게 된다.

가장 이상적인 시나리오는 100명의 개발자가 각자 개발한 코드를 각자 개발이 될때 마다 통합을 시켜주는 것이 좋다.

- 그럼 CI를 적용하면 어떻게 될까

100명의 개발자가 열심히 개발 --> 커밋 --> 로컬 테스트 통과 실패 --> 문제가 되는 부분만 코드 수정 --> 커밋 --> 코드베이스 머지 --> next 작업

--> 가능한 최대한 많이 빨리빨리 내 코드를 코드베이스에 안착시키자, 테스트 코드 없는 무서운 코드 버그 더미 코드를 애초에 코드베이스에서쫒아내자

- 그러면 CD는 왜 필요하냐?

백엔드 코드 개발 --> 백엔드 엔지니어 : "프론트와 협업해야하니 배포를 해볼까?" --> 프론트엔드 개발자 : "저기 배포좀 해주세요..." --> 백엔드 엔지니어 : "버그났는데요" --> 프론트 엔드 개발자가 코드 수정 후 다시 배포 해달라고 요청 --> 또 다른 프론트 엔드 개발자 "데브 서버에 누가 배포했나요? 제꺼 안되는데요;;" --> 개판

프로덕션 배포시 초긴장을 유지하는 안타까운 상황발생

프론트엔드 개발자 입장에서는 코드만 짜면 되지 뭐이리 할게 많냐. 우리 코드만 짜게 해달라. 라는 요구사항이 나올 수 밖에 없다.

- 그러면 CD를 적용하면 어떻게 될까

100명의 프론트엔드 개발자가 열심히 개발 --> 머지 --> 끝. (프론트 엔드 개발자 : "머지됬으니까 내 역할은 여기까지 peace...")

QA 엔지니어와 같은 내부사용자 혹은 실제 production 환경의 사용자에게 지속적이고 안정적으로 서비스를 제공한다.

- 개발자 입장에서 코드 개발만 할건데 나머지 테스트 및 배포 같은 귀찮은 일들은 누가할거냐 라는 의문에서 나온것이 바로 젠킨스이다.

![2](https://user-images.githubusercontent.com/41605276/102005305-25c64080-3d5b-11eb-80f2-1f2ec09c8bfd.PNG)

어떤 서비스 개발시 웬만한 단순 반복작업은 전부 젠킨스에 시킬 수 있다. 농담삼아 어떤 개발자가 퇴사할때 '젠킨스한테 인수인계하세요' 라는 말도 있을정도다.


- 젠킨스 기본특징

1) Java Runtime Environment 에서 동작

젠킨스는 자바 런타임에서 돈다. 그래서 젠킨스가 도는 서버에 자바 런타임(젠킨스를 사용하기 위해 자바가 깔려 있어야 한다는 말이다)이 깔려있어도 되고, 그게 귀찮으면 젠킨스 도커이미지를 다운받아서 써도 된다.

2) 다양한 플러그인들을 활용해서 각종 자동화 작업을 처리할 수 있음

젠킨스가 도는 기본원리는 젠킨스에서 제공하는 다양한 플러그인들을 조합해서 원하는 파이프라인을 구성하는 것이다.

코드가 잘 도는지 테스트도 해야하고, 도커 빌드해서 백업도 해야하고, AWS에 배포도 해야하고 , 기타등등 할게 너무 많으니 이런 각각의 컴포넌트들을 하나의 플러그인으로 모듈화를 시켜놓은 것이다.

젠킨스는 수많은 플러그인들을 지원한다. 대표적인 플러그인으로는 Credentials Plugin, Git Plugin, Docker plugin and Docker Pipeline , Pipeline (핵심 기능인 파이프라인 마저도 플러그인!) 등이 있다.

Credentials Plugin 

Jenkins 는 그냥 단지 서버일 뿐이기 때문에 배포에 필요한 각종 리소스(예를들어 클라우드 리소스 혹은 베어메탈에 ssh 접근 등) 에 접근하기 위해서는 여러가지 그 해당 리소스에 접근하기 위한 권한을 갖고 있어야 한다. 그래서 이런 권한(AWS token, Git access token, etc…) 들을 저장해 주는 플러그인

젠킨스가 깃에서 어떤걸 가져오고, aws에 배포를 하고 뭐 이런 다양한 일을 할텐데 아무 권한없이 할 수는 없다. 그래서 ssh 키나 credential, access token 이런것들을 저장해주는 플러그인이다. 보안에 대한 이슈가 있을수도 있는데 내부개발자들도 볼수 없도록 RSA 암호화를 알아서 해주는 등 보안적인 대책도 있는 기능이다.

Pipeline Plugin : 젠킨스의 핵심 기능인 Pipeline 을 관리할 수 있게 해주는 플러그인

Docker plugin and Docker Pipeline 

Docker agent 를 사용하고 jenkins 에서 도커를 사용하기 위함. 결론은 젠킨스가 도커 이미지 다운받고, 빌드하고 이런것들을 하기위한 플러그인이다.



젠킨스 설치할때 처음에 젠킨스에서 Recommend 해주는 것을 깔면 CI/CD에 필요한 웬만한 플러그인은 다 있다고 생각해도 무방할 정도다.

결론적으로 젠킨스는 빈껍데기이고, 수많은 플러그인들 중에서 필요한 것들을 조합해서 원하는 파이프라인 시나리오를 구현하는 것이다.

3) 일련의 자동화 작업의 순서들의 집합인 Pipeline 을 통해 CI/CD 파이프라인을 구축함

- 젠킨스 WebUI에서 플러그인 목록 화면

아래 화면과 같이 플러그인 목록들이 있고 여기서 필요한 것들을 설치해서 쓸 수 있다.

![3](https://user-images.githubusercontent.com/41605276/102005612-7f2f6f00-3d5d-11eb-8615-90d8c9bbf490.PNG)

- 젠킨스의 핵심 파이프라인이란

개발자가 파이프라인으로 어떤 product 서비스를 배포하는데 이 파이프라인을 구성하는 것이 다양한 플러그인들의 조합이다.

이 파이프라인은 Pipeline DSL(Domain Specific Language)이라는 젠킨스 파이프라인에서만 쓰는 언어로 작성할 수 있다.

파이프라인이란 CI/CD 파이프라인을 젠킨스에 구현하기 위한 일련의 플러그인들의 집합이자 구성.

즉 여러 플러그인들을 이 파이프라인에서 용도에 맞게 사용하고 정의함으로써 파이프라인을 통해 서비스가 배포됨

![4](https://user-images.githubusercontent.com/41605276/102007269-ea337280-3d6a-11eb-9394-07676988f131.png)

- Pipeline을 구성하는 요소

파이프라인이란 CI/CD 파이프라인을 젠킨스에 구현하기 위한 일련의 플러그인들의 집합이자 구성.

즉 여러 플러그인들을 이 파이프라인에서 용도에 맞게 사용하고 정의함으로써 파이프라인을 통해 서비스가 배포됨

결론적으로 젠킨스에서 제공하는 각종 플러그인을 이용하여 CI/CD 파이프라인을 script로 작업 명세서 형태로 정의하면 된다.

script로 작업 명세서 형태로 만드려면 두가지 형태의 Pipeline syntax(Declarative 또는 Scripted Pipeline)를 이용해서 작성하면 된다.

- Pipeline Syntax

section, Declaratives, stage으로 크게 구성이 된다.

Section은 어떤일들을 할 것이고, 누가할 것인지 같은 것들을 정의할 수 있다.

1) Sections

섹션은 크게 Agent section, Post section, Stages section, Steps section로 구성된다.

Agent Section

젠킨스는 많은 일들을 해야 하기 때문에 혼자 하기 버겁다.

여러 slave node 를 두고 일을 시킬 수 있는데, 이처럼 어떤 젠킨스가 일을하게 할 것인지를 지정한다.

젠킨스 노드 관리에서 새로 노드를 띄우거나 혹은 docker 이미지 등을 통해서 처리할 수 있음

어떤 노드안에서 도커 컨테이너를 띄워서 걔한테 어떤 일을 시킬수도 있다.

예를들어서 자바빌드를 해야하는데 젠킨스 서버에 접속해서 자바를 일일히 깔 수 없기 때문에 자바 도커이미지를 하나 받아서 그 안에서 빌드를 시킬수도 있는 것이다. 도커에이전트에게 노드js 컨테이너 안에서 어떤 작업을 하라고 지정할 수 있다. 그러면 도커 이미지를 다운받아서 도커 컨테이너 띄우고 그 안에서 작업하고 이런 일을 할 수 있다.

Post section

각각의 스테이지가 끝난 이후의 결과에 따라서 후속 조치를 취할 수 있다.

Ex) success, failure, always, cleanup

Ex) 성공시에 성공 이메일, 실패하면 중단 혹은 건너뛰기 등등

![6](https://user-images.githubusercontent.com/41605276/102008248-92990500-3d72-11eb-84de-9df6372978c4.PNG)

Stages Section

어떤 일들을 처리할 건지 일련의 stage 를 정의함

Steps Section

한 스테이지 안에서의 단계로 일련의 스텝을 보여줌

![5](https://user-images.githubusercontent.com/41605276/102007935-6a100b80-3d70-11eb-8cee-d3fe25279ca8.PNG)

2) Declaratives

각 스테이지에서 어떤일을 할건지에 대해서 정의하는 것이 Declaratives이다.

Environment, stage, options, parameters, triggers, when 등의 Declarative 가 있음

Environment -> 어떤 pipeline 이나 stage scope 의 환경 변수 설정

Parameter -> 파이프라인 실행시 파라미터 받음

Triggers -> 어떤 형태로 트리거 되는가

When -> 언제 실행되는가

아래에 두번째 그림이 when을 활용한 예시인데 프로덕션 환경에서만 해야하는 어떤 일이 있는 것이다. 그래서 내가 git에서 땡겨온 브랜치가 프로덕션이고, environment가 production일때만 어떤 일을 하라고 정의한 것이다.

예시


![7](https://user-images.githubusercontent.com/41605276/102008491-48b11e80-3d74-11eb-8d9a-cddb63a94ccb.png)

3) steps

스테이지 안에서는 해야할일이 많은데 플러그인들을 이용해서 활용해서 해야할일도 많이 있을것이다. 

예를들어서 빌드를 할때 디렉토리를 옮겨서 빌드를 한다던가, 아니면 어떤 다른 플러그인을 깔아서 거기에서 제공하는 어떤 메소드를 이용해서 일을 처리한다던가 이런식으로 할수 있다.

예를들어서 깃플러그인을 설치하면 깃의 credential을 가져오는 어떤 스텝을 할 수 있는 것이고, 도커플러그인을 설치하면 도커를 가져와서 빌드할 수 있는 어떤 메소드를 활용해서 스텝을 구성할 수 있는 것이다. 

Steps 내부는 여러가지 스텝들로 구성

여러 작업들을 실행가능

플러그인을 깔면 사용할 수 있는 스텝들이 생겨남

플러그인별 스텝 종류들은 https://www.jenkins.io/doc/pipeline/steps/ 에서 참고해보자.

- pipeline 예제 샘플

파이프라인이라는 제일 큰 덩어리를 선언하고, 이 안에서 에이전트로 어떤 젠킨스한테 일을 시킬건지 정해주고, 이 파이프라인에는 어떤작업이 있는지 선언했다. 여기에는 prepare하고 build하는 스테이지로 구성되어 있다. 그리고 prepare라는 스테이지에서 해야하는 step을 정의해줬는데 깃에서 브랜치 땡겨오고, 디렉토리 바꿔서 s3에 업로드를 하는 이런 것들을 정의했다. 

![8](https://user-images.githubusercontent.com/41605276/102008739-1c969d00-3d76-11eb-8d03-00ba5228a6d8.PNG)

- 리눅스에서 젠킨스 설치하는 bash 명령어


```python
sudo yum update -y

# Jenkins 패키지 추가
# 젠킨스를 다운받을 수 있는 yum repo를 다운을 받고, 그 레포에 접근할 수 있는 키를 받는다.
sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat/jenkins.repo && sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key

# Install java, docker, git
sudo yum install -y java-1.8.0-openjdk jenkins git docker

# 자바 버전 8 로 설정
sudo alternatives --config java

sudo service jenkins start
```
