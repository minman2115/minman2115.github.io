---
layout: post
title: "서포트 백터머신 기초개념"
tags: [Classification]
comments: true
---

.

#### 그림, 실습코드 등 학습자료 출처 : https://datascienceschool.net

### # 서포트 백터머신

- 개요

![1](https://user-images.githubusercontent.com/41605276/58070905-bd8e9780-7bd5-11e9-9c95-2f12583c862d.jpg)

- 퍼셉트론을 조금 더 발전시킨 것이 서포트 벡터머신이다. 퍼셉트론의 문제점은 linearly separable 데이터 집합이 있을때 실제로 그 데이터들을 완벽하게 분리하는 선이 하나만 존재하는 것이 아니라 무한하게 많이 존재할 수 있다는 점이다. 그렇다면 그 수많은 구분선이 있다면 어떤 선이 가장 좋은 것인가 라는 것을 생각해야 한다.


- 모델 학습 시 바운더리가 구분선 부근에 바싹 붙어서 설정이 되어 있다면 현재까지는 어디까지나 학습을 위한 일부데이터를 사용했기 때문에 추후 test 데이터를 적용했을시 역시 트레이닝 데이터와 비슷하게 또는 근처에 데이터가 나올 가능성이 높은데 이럴경우 miss classification을 할 가능성이 높아진다.


- 이런 경우를 막기위해서는 데이터 간 구분하는 바운더리를 학습데이터에서 가장 멀리 긋는 것이 필요하다. 상대편 클래스 근처에 있는 최전방의 데이터 들에 대해서 바운더리를 멀리 두는 것이 포인트다. 그래서 나온 개념이 최전방에 있는 데이터들이 서포트 벡터이다. 벡터라는 이름이 붙은 것은 데이터 하나하나가 벡터이기 떄문이다. 이 서포트 벡터를 기준으로 바운더리를 두게 된다. 사실상 서포트 벡터 뒤에 있는 데이터 들은 바운더리를 긋는데 전혀 영향을 주지 않게된다.


- 이 바운더리, 경계선은 서포트 벡터에서 멀리떨어지도록 해야하기 때문에 경계선과 서포트 벡터 사이에 정확하게는 음의 서포트벡터와 양의 서포트벡터 사이에 거리를 마진이라고 칭하고 설정하게 된다. 그래서 가능한한 이 마진을 가장 크게해야하는 것이 중요하다. 마진은 바운더리를 어떻게 그을것인가 각도를 설정하는 것에 따라 360가까이 무수히 많은 방법으로 설정할 수 있다. 서포트 벡터를 기준으로 마진을 설정하는데 그 마진과 경계선이 각도가 직각이 될때 가장 마진의 크기가 커지게된다.


- 이 말을 기하학적으로 보면 선과 점의 거리를 계산해야한다. 기하학적으로 직선의 방정식은 $$\ w^Tx - w_0 = 0 $$ (벡터 w가 가리키는 점을 지나야 한다는 조건을 없애고, 벡터 w에 수직인 직선 x의 방정식) 이렇게 쓸 수 있다. w라는 벡터에 수직이면서 위치는 어느곳이나 상관없다. 이 직선과 점(서포트 벡터)의 거리는 직선의 방정식이 위와 같을때 다음과 같다. $$\ \dfrac{\left|w^Tx' - w_0 \right|}{\|w\|} $$


- 위의 수식을 이용하여 마진을 구할 수 있다. 다음과 같이 N개의 학습용 데이터가 있다고 치자. $$\ (x_1, y_1), (x_2, y_2), \ldots, (x_i, y_i), \ldots, (x_N, y_N) $$ 판별함수모형에서는 y는 -1과 +1 두개의 값을 갖는다. x 데이터 중에서 y값이 1인 데이터를 $$\ x_+ $$, y값이 -1인 데이터를 $$\ x_- $$ 라고 표기한다.


- 판별함수 모형에서 직선인 판별 함수  f(x)는 다음과 같은 수식으로 나타낼 수 있다. 

$$\ f(x) = w^Tx-w_0 $$

- 판별함수에 따라서 y값이 1인 데이터 $$\ x_+ $$ 에 대한 판별함수 값은 양수가 되고, 수식은 다음과 같이 표기할 수 있다. 

$$\ f(x_+) = w^Tx_+ - w_0 > 0 $$

반면에 y값이 -1인 데이터에 대한 판별함수 값은 음수가 되고 수식은 다음과 같다.

$$\ f(x_-) = w^Tx_- - w_0 < 0 $$


- y 값이 +1인 데이터 중에서 판별 함수의 값이 가장 작은 데이터를 $$\ x^+ $$라고 표기하고, y 값이 −1인 데이터 중에서 판별함수의 값이 가장 큰 데이터를 $$\ x^- $$라고 표기한다. 이 데이터들은 각각의 클래스에 속한 데이터 중에서 가장 경계선에 가까이 붙어있는 최전방의 데이터들이다. 이 최전방에 있는 데이터는 몇개가 존재할 수도 있다. 이러한 데이터를 서포트 또는 서포트 벡터라고 한다. 


- 이 서포트에 대해서도 부호조건은 아래와 같이 만족되어야 한다.

$$\ f(x^+) = w^Tx^+ - w_0 > 0 $$

$$\ f(x^-) = w^Tx^- - w_0 < 0 $$

서포트에 대한 판별 함수의 값 $$\ f(x^+) $$, $$\ f(x^-) $$는 위와 같이 부호 조건만 지키면 어떤 값이 되어도 무방하다. 따라서 다음과 같은 조건을 만족하도록 판별 함수를 구한다.

$$\ f(x^+) = w^T x^{+} - w_0 = +1 $$

$$\ f(x^-) = w^T x^{-} - w_0 = -1 $$


- 따라서 판별경계선 $$\ w^T x - w_0=0 $$ 과 최전방 서포트 벡터들간의 거리를 구하여 마진값이 최대가 되도록 목적함수를 설정하여 최적화하면 된다. 부호 조건만 지키면 어떤 값이 되어도 괜찮다. 따라서 위의 수식과 같은 조건을 만족하도록 판별 함수를 구한다. 가장 최전방에 있는 서포트 벡터의 판별함수 값이 1하고 -1이 되도록 노말라이징 시킨 것이다. 판별함수에 양수를 그냥 곱해도 똑같은 양수이기 때문이다. 부호가 바뀌지 않은 것이기 때문에 100프로 똑같은 성능의 판별함수 인것이다. 따라서 판별함수가 하나 있으면 거기에 어떠한 양수를 곱해도 그것들은 똑같은 성능의 판별함수들인 것이다. 그러면 이 판별함수들이 여러개 있으면 헷갈리기 때문에 이 판별함수를 노멀라이즈를 해줘서 상수로만 달라지는 얘들은 그냥 하나도 통일시키기로 하였다. 그래서 양의 서포트 벡터와 음의 서포트 벡터를 기준으로해서 아래와 같은 수식을 만들었다. 이렇게 노멀라이징을 시키면 w에 어떠한 숫자가 곱해져도 판별함수의 기능은 똑같은 것이다.

이렇게 되면 위의 수식들을 고려했을때 다음과 같은 부등식이 성립한다.

$$\ w^Tx_+ - w_o \geq 1 $$

$$\ w^Tx_- - w_o \leq -1 $$

- 따라서 판별 경계선 $$\ w^T x - w_0=0 $$ 과 $$\ x^+ $$, $$\ x^- $$ 사이의 거리는 다음과 같이 계산할 수 있다. 

$$\ \dfrac{w^T x^{+} - w_0}{\| w \|} = \dfrac{1}{\| w \|} $$

$$\ -\dfrac{w^T x^{-} - w_0}{\| w \|} = \dfrac{1}{\| w \|} $$

위의 수식 두개를 합한것을 마진이라고 하며 마진값이 클 수록 더 경계선이 안정적이라고 할 수 있다. 


- 마진은 $$\ \dfrac{w^T x^{+} - w_0}{\| w \|}  -\dfrac{w^T x^{-} - w_0}{\| w \|} = \dfrac{2}{\| w \|} $$와 같이 수식으로 표현할 수 있고, 이 마진값이 최대가 되는 경우는 $$\ \| w \| $$가 최소가 되야 한다.

그런데 //w//와 같이 L1 norm은 최소화 하기 힘들다. 왜냐하면 piecewise linear한 형태이기 때문에 그레디언트 속도조절이 안된다. 그래서 불가피하게 위의 목적함수를 L2 norm 즉 //w//를 제곱한 형태로 바꾸었다. 목적함수를 제곱으로 바꾸면 로스함수가 멀리있을때는 빨리오고, 가까이 있을때는 천천히오는 성질이 생긴다. 그리고 무엇보다도 선형대수로 했을때 내적으로 바뀌기 때문에 계산도 쉬워진다.


- 따라서 다음과 같은 목적함수를 최소화 시키면 된다. 여기 수식에서 앞에 1/2는 추후 계산을 했을때 결과가 더 깔끔하게 산출되기 때문에 넣어준 것이다.

$$\ L = \dfrac{1}{2} ||w||^2 = \dfrac{1}{2} w^T w $$


- 그래서 우리의 목표는 분리를 시키는 판별함수를 찾는데 그게 여러가지가 있을 수 있는데 w놈의 제곱값이 제일 작은 얘를 찾겠다는 것이다. 그렇다면 이 w가 제일작은 것을 찾겠다면 w에 0을 넣어주면 되는거 아니냐라고 말할 수도 있는데 틀린것이다. 우리가 찾는것이 아무 w를 찾는 것이 아니라 분류가 제대로 되는 것 중에서 가장 작은 w를 찾겠다는 것이다. 


- 분류가 되는 선이 무한하게 많은 상황중에 분류가 제대로 되는 것 중에서 위의 목적함수를 최소화시켜야 하기 때문에 최적화문제이긴 최적화 문제이지만 제한조건이 있는 최적화 문제가 된다. 제한조건은 여기서 데이터는 양의 x그룹은 1로 분류가 되고, 음의 x그룹은 -1로 분류가 제대로 되야한다는 것이다. 


- 데이터가 N개가 있다면 어떤 클래스가 되던간에 y값은 플러스 그룹에서는 +1 보다 커야하고 마이너스 그룹에서는 -1보다 작아야 한다. 그러면 전체 데이터를 봤을때 다음과 같은 수식으로 표현할 수 있다.  

위에서 스케일링을 사용하여 모든 데이터에 대해 $$\ f(x_i) = w^Tx_i - w_o $$가 1보다 크거나 -1보다 작게 만들었다는 점을 이용하여 아래와 같은 수식을 도출할 수 있다.

$$\ y_i \cdot f(x_i) = y_i \cdot( w^Tx_i - w_o) \geq 1 \;\;\; ( i = 1, \ldots, N ) $$


위의 수식은 데이터가 n개 있으므로 그 수식도 n개가 모두 만족해야 한다. 데이터가 만개가 있으면 위의 부등식도 만개가 되야한다.


- 따라서 라그랑지 승수법을 사용하여 다음과 같은 목적함수를 최소화 하면 된다. 정확하게는 KKT방법으로 풀어야 한다. 부등식 하나마다 라그랑지 승수를 할당해서 걔랑 곱해서 목적함수를 더해주면 된다. $$\ L = \dfrac{1}{2} w^T w - \sum_{i=1}^N a_i \{ y_i \cdot ( w^Tx_i - w_o) - 1 \} $$

여기에서 원래 목적함수는 $$\ \dfrac{1}{2} w^T w $$이고, 그리고 부등식이 n개가 있는것을 목적함수에서 빼준다. ai은 각각의 부등식에 대한 라그랑주 승수를 표기한 것이다. 이 최적화 문제를 풀어 w, w0, a를 구하면 최종적인 판별함수를 구할 수 있다.


- 만약에 등식제한조건이라면 제한조건의 갯수만큼 라그랑지 멀티플라이어라는 새로운 변수를 만들어서 원래 변수에 오그멘트 시키게 된다. 쉽게말해서 라그랑지 멀티플라이어라는 새로운 변수가 더 늘어난다는 것이다. 그리고 목적함수도 제한조건이 있는 등식앞에 람다를 곱해서 계속 추가해서 변형시킨 것이 새로운 목적함수가 되는 것이다. 그래서 얘같은 경우에는 x나 람다나 똑같은 변수이기 때문에 x로 미분해야하고, 람다로 미분해야하고 다해서 0이 되면 된다. 


- 그런데 지금은 부등식제한조건이기 때문에 조건이 더욱 복잡해진다. 위의 서포트벡터머신의 경우에는 부등식조건에서 g가 음수인 경우이다. 여기서는 목적함수는 똑같아지는데 이 목적함수가 최저값이 되는 조건이 약간 달라지게 된다. 원래 변수들 x에 대해서 미분값이 0이 되야하는데 라그랑지 승수에 대해서는 만약 등식 제한조건  gi 이 있는가 없는가에 따라 최적화 해의 위치가 달라진다면 이 등식 제한조건에 대응하는 라그랑주 승수  λi 는 0이 아닌 값이어야 한다. 람다가 0이라면 원래의 문제와 제한조건이 있는 문제가 같은 문제가 되어 최적화 해의 위치도 같게 나오기 때문이다.(이말은 제한조건이 없다는 말과 같다). 라그랑지 승수가 0이라는 것은 제한조건이 사실상 없다는 말이다.


- KKT 조건에 따르면 부등식 제한 조건이 있는 경우에는 등식 제한조건을 가지는 라그랑주 승수 방법과 비슷하지만  i번째 부등식이 있으나 없으나 답이 같은 경우에는 라그랑지 승수의 값이 ai=0 이 된다. 그러나 서포트벡터머신의 경우는 판별함수의 값 $$\ w^Tx_i - w_o $$이 -1 보다 작거나 1보다 큰 경우이다. 따라서 다음과 같은 수식이 성립한다. $$\ y_i(w^Tx_i - w_o) - 1  > 0 $$


- 학습 데이터 중에서 최전방 데이터인 서포트 벡터가 아닌 모든 데이터들에 대해서는 이 조건이 만족되므로 서포트 벡터가 아닌 데이터는 라그랑지 승수가 0이라는 것을 알 수 있다. 따라서 다음과 같은 라그랑지 승수 조건이 성립한다.

$$\ a_i = 0 \;\; \text{if} \;\; x_i \notin \{ x^{+}, x^{-} \} $$


- 그래서 최적화 조건중에서 첫번째는 원래 있던 변수인 w와 w0에 대해서는 일단 미분한값이 0이 되어야 한다. 다시말해 목적함수  L을  w ,  w0 로 미분한 값이 0이 되어야 하는 것이다.

$$\ \dfrac{\partial L}{\partial w} = 0 $$

$$\ \dfrac{\partial L}{\partial w_0} = 0 $$


위의 식을 풀어서 정리하면 다음과 같다. 

여기서 ai는 스칼라고, yi는 1아니면 -1만 되는 스칼라이다, w와 xi는 벡터이다. 이 w와 xi 피쳐벡터간 곱해지면 스칼라가 되는 점을 참고해야한다.

$$\ \begin{eqnarray}
\dfrac{\partial L}{\partial w} 
&=& \dfrac{\partial}{\partial w} \left( \dfrac{1}{2} w^T w \right) - 
    \dfrac{\partial}{\partial w} \sum_{i=1}^N \left( a_i y_i w^Tx_i - a_i y_i w_o - a_i \right) \\
&=& w - \sum_{i=1}^N  a_i y_i x_i \\
&=& 0
\end{eqnarray} $$

$$\ \begin{eqnarray}
\dfrac{\partial L}{\partial w_0} 
&=& \dfrac{\partial}{\partial w_0} \left( \dfrac{1}{2} w^T w \right) - 
    \dfrac{\partial}{\partial w_0} \sum_{i=1}^N \left( a_i y_i w^Tx_i - a_i y_i w_o - a_i \right) \\
&=& \sum_{i=1}^N  a_i y_i \\
&=& 0
\end{eqnarray} $$

그래서 다음과 같은 수식이 성립한다.

$$\ w = \sum_{i=1}^N a_i y_i x_i $$

$$\ 0 = \sum_{i=1}^N a_i y_i $$ 

이 두 수식을 원래의 목적함수에 대입하여  w ,  w0 을 없애면 다음과 같다.

$$\ \begin{eqnarray}
L
&=& \dfrac{1}{2} w^T w - \sum_{i=1}^N a_i \{ y_i \cdot ( w^Tx_i - w_o) - 1 \}  \\
&=& \dfrac{1}{2} \left( \sum_{i=1}^N a_i y_i x_i \right)^T \left( \sum_{j=1}^N a_j y_j x_j \right) - 
    \sum_{i=1}^N a_i \left\{ y_i \cdot \left( \left( \sum_{j=1}^N a_j y_j x_j \right)^Tx_i - w_o \right) - 1 \right\}  \\
&=& \dfrac{1}{2} \sum_{i=1}^N \sum_{j=1}^N a_i a_j y_i y_j x_i^T x_j - 
    \sum_{i=1}^N \sum_{j=1}^N a_i a_j y_i y_j x_i^T x_j +
    w_0 \sum_{i=1}^N a_i y_i + \sum_{i=1}^N a_i   \\
&=& \sum_{i=1}^N a_i - \dfrac{1}{2}\sum_{i=1}^N\sum_{j=1}^N a_i a_j y_i y_j x_i^T x_j
\end{eqnarray} $$

정리하면 아래와 같다.

$$\ L = \sum_{i=1}^N a_i - \dfrac{1}{2}\sum_{i=1}^N\sum_{j=1}^N a_i a_j y_i y_j x_i^T x_j $$

이때 a는 아래와 같은 조건을 만족해야한다.

$$\ \sum_{i=1}^N a_i y_i = 0 $$

$$\ a_i \geq 0 \;\;\;  ( i = 1, \ldots, N ) $$

- 이렇게 하면 w를 전부 a로 대체를 했기 때문에 이 문제는 w를 구하는 문제가 아니라  a만을 구하는 문제로 바뀌었으므로 듀얼형식이 되었다. 또한 우리가 알고 있는 값이 x하고 y인데 얘네들은 전부 숫자이고, i번째 학습데이터와 j번째 학습데이터의 내적으로 계산되는 숫자인 것이다. 만약에 i번째와 j번째가 같은 클래스이면 플러스이고 다른 클래스이면 마이너스 인 것이다. 숫자가 i,j에 따라 존재하고 i,j의 모든 곱의 합인것이다. a가 가질 수 있는 1부터 n까지의 모든 조합의 곱의 가중합인 것이다. 단, 가중치는 xi와 xj가 어떤것이 골라지느냐에 따라서 변할 수 있다. 즉, quadratic form이 되는 것이다. 듀얼형식으로 바꾸면 수치적으로 박스제한 조건이 있는 이차프로그래밍(quadratic programming) 문제가 되므로 원래의 문제보다는 효율적으로 풀 수 있다.


- 그냥 KKT조건이 있는 문제를 a가 0인 경우와 아닌경우를 분리해서 문제를 두번 풀기 때문에 제한조건이 몇개 안되면 상관이 없는데 여기에서는 제한조건의 갯수가 데이터 갯수만큼 있기 때문에 현실적으로 불가능하다. 그래서 이렇게 듀얼형식으로 바꾼것이다. QP문제는 KKT보다는 간단하게 풀 수 있는 장점이 있다.


- 듀얼형식 문제를 풀어 함수 L를 최소화하는  a를 구하면 예측 모형을 다음과 같이 쓸 수 있다.

$$\ f(x) = w^T x - w_0 = \sum_{i=1}^N a_i y_i x_i^T x - w_0 $$

w0는 $$\ w_0 = w^T x^{+} - 1 $$ 또는 $$\ w_0 = w^T x^{-} + 1 $$ 또는 $$\ w_0 = \dfrac{1}{2} w^T (x^+ + x^{-}) $$로 구한다.

- 여기까지는 모델을 피팅하는 과정을 서술한 것이다. 피팅이라는 것은 W(가중치)계수를 구하는 과정이다. 그런데 계수값이 두개로 이루어져 있는것이 문제였다. W도 있지만 W를 구하는 중간과정으로 a를 알아야했다. w를 찾았기 때문에 피팅은 끝났고, 그다음에 우리는 prediction을 할 수 있다. 다시말해 새로운 x를 넣었을때 그 x가 플러스 그룹인지 마이너스 그룹인지 예측할 수 있다. 이 x를 바로위에 수식에 넣고 판별을 할 수가 있다. 여기에서 첨자가 없는 그냥 x가 예측하고자 하는 데이터 인 것이다.


- 라그랑주 승수 값이 0 즉,  ai=0  이면 해당 데이터는 예측 모형, 즉  w  계산에 아무런 기여를 하지 않으므로 위 식을 실제로는 다음과 같다.

$$\ f(x) = a^+ x^T x^+ - a^- x^T x^- - w_0 $$

여기에서 $$\ x^T x^+ $$는 x와 $$\ x^+ $$ 사이의 코사인유사도, $$\ x^T x^- $$는 x와 $$\ x^- $$ 사이의 코사인유사도이므로 결국 두 서포트 벡터와의 유사도를 측정해서 값이 큰 쪽으로 판별하게 된다. 

- 다시말해 새로운 데이터를 prediction하기 위해 넣으면 기존에 있는 데이터들이랑 유사도를 계산해서 플러스 그룹의 유사도합, 마이너스 그룹의 유사도합 둘중에 누가 더 큰지 알아서 큰 쪽으로 classification한다고 보면 된다. 이렇게하면 데이터가 많아지면 많아질수록 계산양도 엄청나게 커지게 된다. 그런데 서포트벡터머신은 이 판별을하는 라인을 계산을 하고 나면 다시말해 위의 경우처럼 qp문제를 풀고나면 a가 0인 얘들과 a가 양수인 얘들이 섞기게 된다. a가 0인 얘들은 라인을 구하는데 영향을 안미치는 얘이고, a가 0이 아닌 얘들은 라인을 구하는데 영향을 주게된다. 그런데 마진이라는 것은 구할때 계산을 가장 앞에 있는 얘들로 부터 마진을 계산한 것이다. 그러면 가장 전방에 있는 얘들은 a가 양수가 된다. 그리고 최전방에 있지 않은 얘들 전부 a가 0이 된다. 데이터가 엄청 많아도 새로운 데이터를 prediction할때 서포트벡터 빼고는 나머지 데이터들은 의미가 없어지게 된다. 최전방에 있는 서포트벡터가 새로운 데이터를 prediction할때 각 클래스의 대표가 된다. 그래서 각 서포트 벡터 와의 내적을 해서 판별하게 되고 판별 시 연산도 매우매우 간단해진다.


- 서포트벡터머신은 머신러닝 어플리케이션 예를 들어서 지문인식 이런거에 많이 쓰였다. 왜냐하면 트레이닝 할때는 계산양이 많이 들지 모르겠지만, 한번 트레이닝하면 프리딕션할때 계산양이 매우 적기 때문에 이너프러덕트 한번만 하면 되기 때문에 마이크로한 기기에도 다 집어넣을 수 있었다. 컴퓨터 같이 헤비한곳에서 피팅만하고, 쓰는 것은 w값 박혀있는데에서만 쓰는 것이다.

#### 슬랙변수

- 서포트벡터머신은 상당히 큰 제한조건이 있다. 그게 뭐냐면 linear separable해야 한다는 점이다. 만약에 그게 안되는 경우에는 어떻게 해야하나라는 고민에서 나온 개념이 슬랙변수이다. 이 슬랙변수를 서포트백터머신에 추가할 수 있다.


- 만약 데이터가 직선인 판별 경계선으로 나누어지지 않는 즉, linear separable이 불가능한 경우에는 다음과 같이 슬랙변수를 사용하여 개별적인 오차를 허용할 수 있다.


- 원래 판별 함수의 값은 클래스 +1 영역의 샘플 $$\ x_+ $$에 대해 $$\ w^Tx_+ - w_0 \geq 1 $$이고, 클래스 -1 영역의 샘플 $$\ x_- $$에 대해 $$\ w^Tx_- - w_0 \leq -1 $$ 이어야 한다.


- 슬랙변수는 원래 부등식제한조건을 등식제한조건으로 바꾸는데 사용되는 개념이다. 제한조건을 완화한다는 의미가 있다. slack 이라는 말이 '느슨하게 하다'라는 뜻이 있다.


- 어떤식으로 완화하는가. 

$$\ w^Tx_+ - w_0 \geq +1-\xi_i $$ , 

$$\ w^Tx_- - w_0 \leq -1+\xi_i $$ 

처럼 +1, -1 딱 이렇게 제한조건을 주는게 아니라 데이터 하나하나에 대해 약간의 융통성을 준다는 의미이다. 수식에서 크사이가 이를 나타내주고 있다.


- 크사이가 0이면 융통성을 주지 않는다는 의미이고, 크사이가 1이라면 경계선까지 융통성을 늘리겠다는 의미이다. 만약에 1보다 더 크다 그러면 경계선을 넘어서겠다는 의미이다. 일부 데이터에 따라 이런 허용치를 융통성으로 허용하겠다는 것이다.


- 사실상 1보다 크다는 것은 얘는 그냥 오분류를 해도 상관이 없다는 의미이다.


- 크사이는 데이터마다 하나씩 주어지기 때문에 데이터마다 융통성이 다르게 적용된다는 것을 알 수 있다. 또한 0보다 같거나 클때 의미가 있으므로 모든 슬랙변수는 0보다 크거나 같다.


- 크사이는 어쨌든 융통성이기 때문에 가능한한 최소화해야한다. 


- 따라서 이런 슬랙변수까지 고려하게되면 목적함수는 다음과 같아진다.
$$\ L = \dfrac{1}{2} ||w||^2 - \sum_{i=1}^N a_i (y_i \cdot ( w^Tx_i - w_o) - 1 + \xi_i ) - \sum_{i=1}^N \mu_i \xi_i  + C \sum_{i=1}^N \xi_i $$

- 여기서 $$\ C \sum_{i=1}^N \xi_i $$는 슬랙변수 합이 너무 커지지않도록 제한한다. 또한 위식에서 시그마 뮤i는 크사이가 0보다 같거나 크다는 부등식제한조건에 대한 라그랑지 멀티플라이어다.


- 슬랙변수는 SVC 클래스에서 C 파라미터를 통해서 조절할 수 있다. 여기서 c는 슬랙변수의 가중치 C를 말하는 것이다.

- $$\ C \sum_{i=1}^N \xi_i $$는 슬랙변수가 지나치게 커지는 것을 막아주는 패널티 조건이다. 다시말해 오분류가 되는 데이터를 최소한으로 줄이기 위한 장치라고 할 수 있다. 그 패널티를 강경하게 주느냐 약하게 주느냐를 결정하는 것이 C다. 이 C가 커지면 커질 수록 오분류가 되는 것을 막겠다는 의도이다.

- 슬랙변수의 가중치 C가 커지면 서포트 벡터의 수가 줄어들고, 반면에 작아지면 서포트 벡터의 수가 증가하는 영향이 있다.


- 그래서 C를 만약에 크게하지 않고 작게한다는 것은 몇개의 데이터는 오분류되도 상관이 없지만 대신에 마진을 넓혀서 안정적으로 분류가 가능하게 하도록 집중해라라는 의미이다.


- 전방에 나와있는 데이터들이 나타나기 힘든데이터들이라면 경우에 따라서 선형분리되지 않은 문제도 풀수가 있다.


- 슬랙변수를 주는데 가중치를 작게주게 되면 서포트벡터의 갯수가 늘어나게 된다. 이렇게 서포트 벡터가 여러개가 있는 경우 prediction을 할때 이 서포트 벡터의 평균을 내서 유사도를 구하는 방식으로 한다. 다시말해서 슬랙변수의 가중치를 작게 두면 서포트 벡터의 수가 늘어나게 되서 서포트 벡터가 혹시나 아웃라이어일 경우를 대비하여 위와 같이 평균을 내서 유사도를 구하는 방식으로 안정적인 방안을 취할 수 있다.


- 서포트 벡터머신은 이미지 classification할때 많이 쓰이는 모델이다. 이미지는 상당히 고차원이기 때문에 사람이 볼때는 모르겠지만 이런 상당히 고차원에서는 이 이미지들이 상당히 떨어져 있는 linearly separable한 데이터이다. 서포트 벡터 머신은 이 떨어진 차원의 데이터에 대해 경계선을 잘 그을 수 있다.


- 아래는 scikit-learn 패키지 내장 데이터인 '올리베티 페이스' 이미지를 서포트벡터 머신으로 모델링하여 테스트한 성능을 구현한 실습코드이다. classification report를 보면 알 수 있듯이 90% 이상의 뛰어난 성능을 보여준다.


```python
## 올리베티 이미지 임포트
from sklearn.datasets import fetch_olivetti_faces
faces = fetch_olivetti_faces()

## train & test 데이터 분리
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(faces.data, faces.target, test_size=0.3, random_state=0)

## 서포트벡터 머신을 이용한 모델학습
from sklearn.svm import SVC
svc = SVC(kernel='linear').fit(X_train, y_train)

## 모델테스트
from sklearn.metrics import classification_report, accuracy_score
y_pred_test = svc.predict(X_test)

## 결과전시
print(classification_report(y_test, y_pred_test))
```

                  precision    recall  f1-score   support
    
               0       0.86      1.00      0.92         6
               1       1.00      1.00      1.00         4
               2       1.00      1.00      1.00         3
               3       0.33      1.00      0.50         1
               4       1.00      1.00      1.00         2
               5       1.00      1.00      1.00         5
               6       1.00      0.80      0.89         5
               7       1.00      0.67      0.80         3
               8       1.00      1.00      1.00         2
               9       1.00      1.00      1.00         2
              10       1.00      1.00      1.00         4
              11       1.00      1.00      1.00         1
              12       1.00      1.00      1.00         2
              13       1.00      1.00      1.00         3
              14       1.00      1.00      1.00         5
              15       1.00      0.60      0.75         5
              16       0.00      0.00      0.00         0
              17       1.00      1.00      1.00         6
              19       1.00      1.00      1.00         4
              20       1.00      1.00      1.00         1
              21       1.00      1.00      1.00         2
              22       1.00      1.00      1.00         2
              23       1.00      1.00      1.00         2
              24       1.00      1.00      1.00         2
              25       1.00      1.00      1.00         4
              26       1.00      1.00      1.00         4
              27       1.00      1.00      1.00         1
              28       1.00      1.00      1.00         3
              29       1.00      1.00      1.00         5
              30       1.00      1.00      1.00         4
              31       1.00      1.00      1.00         4
              32       1.00      1.00      1.00         3
              33       1.00      1.00      1.00         2
              34       1.00      0.83      0.91         6
              35       1.00      1.00      1.00         1
              36       1.00      1.00      1.00         4
              37       1.00      1.00      1.00         3
              38       1.00      1.00      1.00         1
              39       0.75      1.00      0.86         3
    
       micro avg       0.96      0.96      0.96       120
       macro avg       0.95      0.95      0.94       120
    weighted avg       0.98      0.96      0.96       120
    
    

    C:\Users\minman\Anaconda3\lib\site-packages\sklearn\metrics\classification.py:1145: UndefinedMetricWarning: Recall and F-score are ill-defined and being set to 0.0 in labels with no true samples.
      'recall', 'true', average, warn_for)
    C:\Users\minman\Anaconda3\lib\site-packages\sklearn\metrics\classification.py:1145: UndefinedMetricWarning: Recall and F-score are ill-defined and being set to 0.0 in labels with no true samples.
      'recall', 'true', average, warn_for)
    C:\Users\minman\Anaconda3\lib\site-packages\sklearn\metrics\classification.py:1145: UndefinedMetricWarning: Recall and F-score are ill-defined and being set to 0.0 in labels with no true samples.
      'recall', 'true', average, warn_for)
    

- 과거에는 그래서 이미지 분석 시 서포트 벡터머신이 가장 많이 쓰였고, 참고로 피쳐가 여러가지가 섞여있을때는 랜덤포레스트 또는 부스팅방법이 과거에 또한 많이 쓰였다.
