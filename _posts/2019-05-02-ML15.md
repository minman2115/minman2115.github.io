---
layout: post
title: "Model combining 기초개념"
tags: [Classification]
comments: true
---

.

#### # 학습 시 참고한 URL : https://datascienceschool.net

#### 1. Model combining 개요

![1](https://user-images.githubusercontent.com/41605276/57061961-cb997880-6cf9-11e9-9527-818c2d9c85fa.jpg)

- 모형결합은 앙상블 방법론이라고도 부른다. 지금까지 어떤 문제를 풀때 우리가 알고 있는 분류 모델중에서 특정데이터에 적합한 모델을 선택했다. 예를 들어서 텍스트 데이터 같은 경우에는 피쳐가 엄청 많기 때문에 나이브 베이즈 모형이 효율적이었다. 그러나 앙상블방법은 우리가 알고있는 모형들을 섞어서 다수결방법으로 하는 방법이다.


- 한문제를 풀때 모형을 여러개를 같이 쓴다고 할 수 있다. 이렇게하면 두가지 장점이 있다. 


1) 트레이닝을 할때 항상 주의해야할게 오버피팅이지만 성능을 높인다고 욕심을 내다 보면 그만큼 오버피팅의 위험성도 커지는 것이다. 그래서 정규화도하고 교차검증도 하고 오버피팅 등을해서 방지하는데 이렇게 모델을 여러가지 종류를 같이 쓰게되면 오버피팅이 잘 안일어난다. 오버피팅은 잘 안일어나면서 성능은 안정적으로 나오게 된다. 


2) 개별 모형이 성능이 안좋을 경우에는 결합모형을 해주면 성능이 더 향상된다. 쉽게 말해 수학문제를 풀때 한명이 푸는 것보다 여러명이 푸는게 더 성능이 좋아지는 것과 비슷하다. 특히 그닥 머리가 좋지 않는 사람 여러명이 풀었을때는 효과가 더욱 커진다. 이런경우를 여러 weak Classifier가 결합했다고 말한다.


- 모형이 여러개가 있을때 걔들을 결합시키는 방법을 크게 나누어서는 두가지 접근이 있다.


1) aggregation 방법

그룹이 아예 처음부터 정해져있다. 10명이면 10명, 100명이면 100명 이런식으로 정해서 문제를 100명이 다같이 똑같은 문제를 푼다. 

aggregation 방법에는 다수결방법, 배깅, 랜덤포레스트 등이 있다.


2) boosting 방법

처음부터 인원수가 정확하게 정해진 것은 아니다. 처음에는 모델 하나가 문제를 풀기 시작한다. 그러다가 얘가 잘 못푸는 문제가 있으면 그거를 도와주기 위해 두번째 멤버가 참여하게 된다. 두번째 멤버는 푸는 목표자체가 첫번째 모델과는 다르다. 두번째 멤버의 목표는 첫번째 멤버가 못푸는 문제를 잘 푸는 것이 목표이다. 그래서 여기에 들어가는 모델들의 타겟 데이터 자체가 아예 다르다. 세번째 멤버는 앞에 두명이 머리를 합쳐서 무언가를 풀었는데 그 둘이 잘 못푸는 문제를 얘는 풀려고 노력한다. 이런식으로 멤버가 한명씩 추가가 된다.

부스팅 방법에는 에이다부스트, 그레디언트 부스트 방법등이 있다.


- 가장 단순한 모형결합 방법으로 다수결방법에 대해 알아보자. 다수결 방법은 한문제를 푸는데 여러 모델로 풀어서 취합을 한다음 판별을 하는 방법이다. 취합을 할때 두가지 방법이 존재한다. 하나는 hard voting이고 하나는 soft voting이다. 


- hard voting은 투표하는 얘들이 모두 동등하게 하나의 투표권을 갖는 방법이다. hard voting을 할때 멤버의 수가 짝수인경우 동점이 나올 가능성이 있는 단점이 있어서 나온 방법이 soft voting이다. 


- soft voting은 우리가 분류문제를 풀면 실제로 내부적으로 decision function이나 혹은 y가 1일 확률을 계산하거나 y가 0일 확률을 계산하게 되는데 이 확률값을 일종에 투표수 같은거로 생각해서 각각의 모델에서 나온 확률값을을 더해서 총합을 분류하고자하는 카테고리별로 비교하게 되는 방식이다. 이렇게 하드보팅과 소프트보팅 방식이 다르기 때문에 똑같은 데이터으로 모형결합을 해도 다른 결과가 나올 수 있다.

#### 2. 모형결합을 사용한 성능향상

![2](https://user-images.githubusercontent.com/41605276/57061989-dfdd7580-6cf9-11e9-84ed-9346395746a0.jpg)

- 모형 결합을 사용하여 성능이 향상되는 것을 수학적으로 확인할 수 있다. 개별모형들이 다른 모형의 눈치를 보지 않고 서로 독립적으로 판단한다는 가정하에 다수결 모형은 $$\ \sum_{k>\frac{N}{2}}^N \binom N k p^k (1-p)^{N-k} $$와 같은 수식으로 정확도를 출력하게 된다. N개의 모델이 모였는데 걔가 올바른 답을 낼 확률은 무엇인가를 계산한 것이다. 올바른 답을 내려면 N개 중에서 적어도 그 N개중의 반이상 즉, N/2개의 멤버들이 올바른 판단을 해야한다. 그래야지 다수결로 이길 수 있기 때문이다. 그래서 k가 N/2보다 많아지는 케이스 여기서 k는 올바른 결정을 내린 멤버의 갯수이다. 그러면 k개의 멤버가 올바른 결정을 내릴 수 있는 확률은 하나하나가 올바른 결정을 내릴 확률이 p이기 때문에 k개는 올바른 가능성인 p의 k승이 나와야 하고 나머지 N-k개는 잘못된 판단을 내리는 확률이다. 그것이 1-p이다. k개는 만약에 10개중에 3개라고 하면 앞에있는 연속적인 1,2,3번 모델만 세개가 아니기 때문에 다시말해 4,5,6 또는 6,3,2 등 여러가지 조합이 될 수 있기 떄문에 N개중에 k개를 뽑는 방법의 갯수는 콤비네이션으로 계산할 수 있다. 결론적으로 위의 식은 모형결합했을때 전체모델의 정확도를 계산하는 식이다.


- aggregation 방법의 가장 좋은점은 여러 모델을 쓰는데 각각 하나의 모델을 엄청나게 좋은 모델을 쓸 필요가 없다. 각각 하나의 모델은 단순한 모델을 써도 된다는 것이다. 단 조건은 그 모델이 50점은 넘는 얘들을 써야한다. 


- 현실적으로 aggregation 방법에서 가장 많이쓰는 것은 decision tree인데 depth가 1개인 이런 weak Classifier(정확도 0.5를 간신히 넘기는 단순한 분류모형들)인데 그런얘들을 100개나 1000개를 모으게 되면 99% 가까운 성능이 나올 수 있다. 단 여기에는 중요한 가정이 있는데 각각의 모델들은 서로 눈치를 보면 안되고 독립적으로 판단해야 한다.

#### 3. bagging

![3](https://user-images.githubusercontent.com/41605276/57062007-ea980a80-6cf9-11e9-9e69-6719935008d7.jpg)

- 문제는 이런 단순한 모형을 많이 모을수록 좋은데 우리가 알고 있는 모형의 종류는 사실 많지 않다. 그러면 모형 100개를 어떻게 모으느냐 사람들이 고민해서 나온 방법이 배깅방법이다. 그러면 어떻게 100개나 1000개를 만드냐. 특정 똑같은 모델을 여러개 쓰는데 대신에 그 모델에 들어가는 데이터를 다르게 주면 된다. 


- 배깅은 동일한 모형과 모형 모수를 사용하는 대신에 부트스트래핑과 유사하게 트레이닝 데이터를 랜덤하게 선택해서 다수결 모형을 적용한다. 트레이닝 데이터를 선택하는 방법에 따라 다음과 같이 부르기도 한다.

1) 같은 데이터 샘플을 중복사용하지 않을 시 : Bagging


2) 같은 데이터 샘플을 중복사용할 시 : Pasting


3) 데이터가 아니라 다차원 독립 변수 중 일부 차원을 선택하는 경우 : Random Subspaces


4) 데이터 샘플과 독립 변수 차원 모두 일부만 랜덤하게 사용하면 : Random Patches

model test에는 트레이닝용으로 선택한 데이터가 아닌 다른 데이터를 사용할 수도 있다. 이런 데이터를 OOB(out-of-bag) 데이터라고 한다.

- 우리가 aggregation 방법의 모델을 만들때 가능하면 구성하는 모델간에 서로 독립적이게 만들어야 한다면 랜덤패치 방법을 이용한 모델이 가장 낫다고 할 수 있다. 이런 방법을 구현해줄 수 있는 것이 Scikit-Learn에서 BaggingClassifier 클래스이다.


- 배깅방법의 또다른 좋은 장점은 데이터를 전부쓰는 복잡한 모델하나보다 아웃라이어 때문에 모델이 올바르게 피팅이 안될 가능성이 적어진다는 것이다.


- 모형결합의 장점을 정리하면 개별 Classifier가 퍼포먼스가 50%만 넘으면 걔네들은 많이 모이면 모일수록 퍼포먼스가 훨씬 더 좋아질 수 있다. 두번째 장점은 배깅방식처럼 다수결로 하게되면 오버피팅이 잘 발생하지 않는다. 자동으로 정규화가 된다는 것이 장점이다.
